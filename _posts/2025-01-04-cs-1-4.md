
---
layout: post
title: 대표적인 디자인 패턴
subtitle: 개발자로서 알아야 할 디자인 패턴
tags: [CS]
comments: true
author: CoderNyang
---

## **1.4 대표적인 디자인 패턴**

### 1.4.1 싱글톤(Singleton) 패턴

1. **개념**

   * 프로그램 전체에서 **딱 하나의 객체**만 존재하도록 하는 패턴
   * ‘인스턴스가 유일해야 하는’ 상황에서 사용

2. **예시**

   * **로그 관리 객체**: 시스템 전체 로그를 하나의 객체에서 취합
   * **데이터베이스 연결 객체**: 여러 곳에서 DB에 접근하더라도 하나의 연결을 쓰도록 관리

3. **장점**

   * 전역적으로 객체를 공유해야 할 때 유용
   * 하나의 인스턴스만 유지되므로 **메모리 절약** 가능

4. **단점**

   * 전역 객체처럼 사용되므로, 무분별한 사용 시 **결합도**가 높아질 수 있음
   * 멀티쓰레드 환경에서 싱글톤 생성 시 동기화 문제가 발생할 수 있음

***

### 1.4.2 팩토리(Factory) 패턴

1. **개념**

   * 객체 **생성 과정**을 별도의 ‘팩토리’ 객체(혹은 메서드)에 위임하는 패턴
   * 객체를 사용하는 코드는 “어떤 클래스가 생성되는지” 구체적으로 몰라도 됨

2. **예시**

   * **자동차 공장**: 사용자는 “자동차를 만들어 주세요”라고만 요청 → 어떤 방식으로 조립되고 도색되는지는 몰라도 됨
   * **GUI 툴킷**: “윈도우 버튼”과 “맥 버튼” 생성 방식을 팩토리로 분리하면, 코드 수정 없이 운영체제별 버튼 교체 가능

3. **장점**

   * **객체 생성 로직을 분리**하여 코드가 깔끔해짐
   * 제품(객체)군이 변경되어도 **팩토리만 수정**하면 되므로 유지보수성이 올라감

4. **단점**

   * “팩토리 객체” 혹은 “팩토리 메서드” 자체가 복잡해지면, 관리가 필요

***

### 1.4.3 전략(Strategy) 패턴

1. **개념**

   * 알고리즘(행위, 전략)을 **별도 객체**로 캡슐화하여, **런타임**(실행 중)에 자유롭게 교체 가능한 구조
   * “상황에 따라 다른 알고리즘을 써야 해!” 하는 문제에 적합

2. **예시**

   * **정렬 전략**: 데이터 양이나 특성에 따라 퀵 정렬, 병합 정렬, 버블 정렬 등을 교체
   * **결제 수단**: 결제 모듈에서 ‘카드 결제’, ‘계좌 이체’, ‘카카오페이 결제’ 등 다양한 전략을 선택해 적용

3. **장점**

   * 필요에 따라 전략 객체만 교체해도 로직을 쉽게 변경할 수 있음
   * **오픈-클로즈드 원칙(OCP)** 준수: 기존 코드를 수정하지 않고 새 전략(알고리즘)을 추가 가능

4. **단점**

   * 알고리즘이 많아질수록 전략 클래스 파일이 늘어날 수 있음

***

### 1.4.4 옵저버(Observer) 패턴

1. **개념**

   * 어떤 객체(주체, Subject)의 상태 변화가 일어나면, **등록된 옵저버들에게 자동으로 알림**
   * **이벤트 기반** 시스템에서 자주 활용

2. **예시**

   * **유튜브 구독**: 채널(Subject)이 새 영상을 업로드하면, 구독자(Observer)에게 알림
   * **UI 이벤트**: 버튼을 클릭하면, 여러 리스너(Observer)가 해당 이벤트를 동시에 받아 처리

3. **장점**

   * ‘주체’ 객체와 ‘옵저버’ 객체 간 결합이 느슨해져, 확장 및 유지보수가 쉬움
   * N개의 옵저버가 있어도, 주체는 “알림만” 보내면 돼서 편리

4. **단점**

   * 옵저버가 많을수록, 알림 시 성능 부담이 늘어날 수 있음(브로드캐스트)
   * 복잡한 옵저버 구조에서, **순환 참조**(다른 옵저버가 또 다른 주체의 옵저버인 경우 등)에 주의

***

### 1.4.5 프록시(Proxy) 패턴

1. **개념**

   * 실제 객체(Real Subject)를 직접 호출하는 대신, \*\*대리 객체(Proxy)\*\*를 두어 **접근 전후 로직**을 제어
   * 권한 제어, 캐싱, 로깅, 지연 로딩 등의 기능을 구현하기 쉬움

2. **예시**

   * **프록시 서버**: 외부 서버와 통신할 때, 중간에 프록시 서버를 두어 보안/캐싱/트래픽 분산 처리
   * **가상 프록시**: 이미지 로딩 등 리소스가 큰 객체를 ‘실제 필요할 때’만 생성하는 방식

3. **장점**

   * **접근 제어**: 민감 자원에 대한 접근을 제한할 수 있음
   * **추가 기능 삽입**이 편리: 권한 체크, 로깅, 성능 모니터링 등을 Proxy가 처리

4. **단점**

   * 호출 과정이 한 단계 더 생기므로, **오버헤드**가 발생할 수 있음
   * Proxy 객체와 Real 객체 간 **동기화**에 주의해야 함

***

### 1.4.6 MVC(Model-View-Controller) 패턴

1. **개념**

   * 애플리케이션을 **Model, View, Controller** 세 영역으로 나누어 설계하는 구조

     * **Model**: 데이터, 비즈니스 로직 (DB 접근, 데이터 가공 등)
     * **View**: 화면, 사용자에게 보이는 영역 (UI)
     * **Controller**: 사용자 입력을 받아서 Model과 View를 연결 (흐름 제어)

2. **예시**

   * **웹 프레임워크**에서 거의 표준처럼 사용
   * Java Spring MVC, Django(파이썬), Ruby on Rails 등이 대표적

3. **장점**

   * **분리된 구조**로 인해, 유지보수와 협업에 유리
   * 한쪽(Model) 수정이 다른 쪽(View, Controller)에 큰 영향을 주지 않음

4. **단점**

   * 규모가 작은 프로젝트에서는 다소 복잡해 보일 수 있음
   * 실제 구현 시 Model과 Controller 사이의 로직이 복잡해지면, 구조가 어지러워질 수 있음


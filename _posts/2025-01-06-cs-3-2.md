---
layout: post
title: 프로세스와 스레드
subtitle: 개발자로서 알아야 할 프로세스와 스레드
tags: [CS]
comments: true
author: CoderNyang
---


## **3.2 프로세스와 스레드**<br/>

### 3.2.1 프로세스(Process)와 컴파일 과정

1. **프로세스란?**

   * **프로그램이 메모리에 로드되어 실행 중인 상태**를 말해요.
   * 디스크(SSD/HDD)에 있는 “정적인 프로그램 파일”이 실제로 실행되어,\
     **CPU와 메모리를 할당받은 동적인 실행 단위**가 바로 “프로세스”입니다.<br/>

2. **컴파일 과정** (예: C, C++ 등 정적 컴파일 언어 기준)

   * **소스 코드(코드 작성)** → (컴파일러) → **오브젝트 코드(목적 파일)**
   * 여러 오브젝트 파일과 라이브러리를 합쳐서 → (링커) → **실행 파일(Executable)**
   * 이 실행 파일이 운영체제에 의해 메모리에 적재(로드)되면, 비로소 프로세스로 동작<br/>

3. **프로그램 vs 프로세스**

   * “프로그램”은 단순히 디스크에 저장된 **정적**인 파일.
   * “프로세스”는 그 프로그램이 **실행되어**, 운영체제로부터 **자원(CPU, 메모리 등)을 할당받은** **동적**인 개체.<br/>


### 3.2.2 프로세스의 상태

1. **생성(New)**

   * 프로세스가 만들어지고, 아직 준비가 완료되지 않은 상태<br/>

2. **준비(Ready)**

   * CPU를 할당받기 전, “실행 대기 중”인 상태
   * CPU가 놀기만 하면, Ready 상태 중 하나를 골라(Run) 실행<br/>

3. **실행(Running)**

   * 실제로 **CPU를 할당받아** 명령어가 실행되고 있는 상태<br/>

4. **대기(Waiting or Blocked)**

   * 입출력(I/O) 작업 등으로 CPU가 아닌 **외부 자원**이 필요해, 대기 중인 상태
   * 예: 파일 읽기를 요청하고, 디스크 읽기가 완료될 때까지 기다릴 때<br/>

5. **종료(Terminated)**

   * 프로세스 실행이 완료되어 운영체제 관리에서 벗어난 상태<br/>

> 프로세스는 **각 상태를 왔다 갔다**하면서 최종적으로 종료 상태에 이릅니다.


### 3.2.3 프로세스의 메모리 구조

보통 프로세스는 다음과 같은 메모리 구조(“주소 공간”)를 가집니다:

1. **코드(Code) 영역**

   * 프로그램의 **실제 실행 명령어(기계어)**가 저장
   * CPU가 이 영역의 명령어를 하나씩 가져와서 실행<br/>

2. **데이터(Data) 영역**

   * 전역 변수(Global), 정적 변수(Static)가 저장
   * 프로그램 시작부터 종료까지 메모리에 상주<br/>

3. **힙(Heap) 영역**

   * **동적 할당 메모리**(`malloc`, `new` 등)를 위한 공간
   * 런타임에 필요한 만큼 메모리를 할당하거나 해제<br/>

4. **스택(Stack) 영역**

   * 함수 호출 시, **지역 변수**나 함수 인자, 리턴 주소 등이 저장
   * 함수가 호출되면 스택 영역을 ‘쌓고’, 반환되면 ‘되돌리는(POP)’ 방식<br/>


### 3.2.4 PCB(Process Control Block)

1. **PCB란?**

   * 운영체제가 프로세스를 관리하기 위해 보관하는 **정보(데이터 구조)**
   * 프로세스가 생성될 때 PCB가 만들어지고, 프로세스가 종료되면 PCB도 사라짐<br/>

2. **PCB에 담기는 정보**

   * **프로세스 상태** (Ready, Running, Waiting 등)
   * **프로세스 ID** (PID)
   * **프로그램 카운터(PC)**: 다음에 실행할 명령어 주소
   * **CPU 레지스터 정보**
   * **메모리 관리 정보** (페이지 테이블, 세그먼트 정보 등)
   * **우선순위**
   * **입출력 상태**
   * **회계(계정) 정보** 등

> 문맥 전환(Context Switch) 시, 현재 PCB에 레지스터 상태 등을 저장하고, 새 프로세스 PCB 정보를 불러와 CPU를 재설정합니다.


### 3.2.5 멀티프로세싱

1. **멀티프로세스(Multi-Process)**

   * 여러 프로세스를 **동시에** 실행하는 환경
   * 실제로는 **CPU가 하나라면 시분할**로 번갈아가며 실행, CPU가 여러 개면 물리적으로 병렬 실행도 가능
   * 각각의 프로세스는 **독립된 메모리 공간**을 갖기 때문에, 하나가 비정상 종료돼도 다른 프로세스에는 영향이 적음<br/>

2. **장점**

   * 프로그램들이 서로 독립되어 있어, **안정성**이 높음
   * 여러 CPU 코어가 있을 때, 병렬로 처리해서 **성능 향상**<br/>

3. **단점**

   * 프로세스 간 **메모리 분리**로 인해, 서로 데이터를 공유하려면 IPC(프로세스 간 통신) 기법이 필요 → 약간 복잡
   * 프로세스 생성이나 문맥 전환 오버헤드가 크다<br/>


### 3.2.6 스레드(Thread)와 멀티스레딩(Multi-Threading)

1. **스레드(Thread)란?**

   * 프로세스 내부에서 **실제로 일(실행)을 하는 흐름**
   * 한 프로세스 안에 **여러 스레드**가 존재할 수 있으며, **코드/데이터/파일 등 대부분 자원을 공유**
   * 예: 웹 브라우저 프로세스 안에 탭마다 스레드가 분리되어 동작<br/>

2. **멀티스레딩(Multi-Threading)**

   * 하나의 프로세스 내에서 스레드를 여러 개 실행해 **동시 처리**
   * 예: 게임 프로세스 → 그래픽 처리 스레드, 사운드 처리 스레드, 네트워크 스레드 등<br/>

3. **장점**

   * 프로세스 하나만 실행되더라도, 내부적으로 여러 일을 병렬 혹은 동시(시분할) 처리 가능
   * **메모리나 자원 공유**가 쉽고, 문맥 전환이 가벼워 CPU 스케줄링 효율이 높아짐<br/>

4. **단점**

   * 스레드들이 자원을 공유하기 때문에, **동기화 문제**(임계영역 충돌), 교착 상태(Deadlock) 등이 발생하기 쉬움
   * 하나의 스레드가 오류로 죽으면, 같은 프로세스 내 다른 스레드들도 영향을 받을 수 있음

> 즉, **프로세스는 독립적인 실행 단위**, **스레드는 프로세스 내부의 실행 흐름**으로 이해하면 됩니다.


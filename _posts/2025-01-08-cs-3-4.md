---
layout: post
title: CPU 스케줄링 알고리즘
subtitle: 개발자로서 알아야 할 CPU 스케줄링 알고리즘
tags: [CS]
comments: true
author: CoderNyang
---


## **3.4 CPU 스케줄링 알고리즘**<br/>

운영체제는 **여러 프로세스(또는 스레드)** 중 어떤 것에 **CPU를 먼저 할당할지 결정**해야 합니다.\
이 결정 과정을 **CPU 스케줄링**이라고 부르며, 다양한 알고리즘이 존재합니다.<br/>

### 3.4.1 비선점형(Non-preemptive) 방식

* **비선점**: “한 번 CPU를 잡은 프로세스가 **스스로** 종료하거나, I/O 대기로 떠날 때까지 빼앗기지 않는” 방식
* 즉, **프로세스가 CPU를 점유**하면 **운영체제**가 강제로 중간에 **빼앗지 않는** 구조<br/>

1. **FCFS(First-Come, First-Served)**

   * **도착한 순서**(대기열에 들어온 순서)대로 CPU를 할당
   * 간단하고 직관적이지만, **“대기 시간이 너무 길어질 수 있다”**는 단점도 존재 (특히 긴 작업이 먼저 오면 뒤에 온 짧은 작업이 오래 기다릴 수 있음)<br/>

2. **SJF(Shortest Job First)**

   * **처리 시간이 가장 짧은** 작업에게 우선적으로 CPU를 할당
   * 평균 대기 시간을 줄이는 데 효과적
   * 하지만 **앞으로 들어올 작업**의 실행 시간을 정확히 모르면 적용하기 어려운 측면이 있음<br/>

3. **우선순위(Priority) 스케줄링** (비선점형 버전)

   * 프로세스마다 **우선순위(숫자 등)**를 부여해, **가장 높은 우선순위**를 가진 프로세스에 CPU 할당
   * 우선순위가 낮은 프로세스는 오래 기다릴 수도 있음(기아 문제, starvation)
   * “나이가 들수록(오래 기다리면) 우선순위를 높인다” 같은 방식으로 기아 문제를 해결하기도 함<br/>


### 3.4.2 선점형(Preemptive) 방식

* **선점**: CPU를 할당받은 프로세스가 **아직 종료하지 않았어도**, **운영체제**가 **중간에 CPU를 빼앗아** 다른 프로세스에 할당할 수 있음
* 시분할(Time Sharing) 시스템 등에서 흔히 사용됨<br/>

1. **Round Robin (RR, 라운드 로빈)**

   * **시분할** 기법의 대표적인 예시
   * 준비 큐(Ready Queue)에 있는 프로세스들에게 **정해진 시간 할당량(Time Quantum)** 만큼 번갈아 CPU를 할당
   * 예: Time Quantum= 1초 → 각 프로세스가 1초씩 CPU를 쓰고, 다음 프로세스로 넘어감
   * 모든 프로세스가 **공평**하게 CPU 사용 기회를 갖지만, 지나치게 작은 할당량은 **문맥 전환(스위칭) 오버헤드**를 증가시킴<br/>

2. **SRTF (Shortest Remaining Time First)**

   * SJF의 선점형 버전
   * **실행 중인 프로세스**보다 **더 짧은 남은 시간을 가진** 새 프로세스가 도착하면, 현재 프로세스를 선점(중단)하고 **새 프로세스**에 CPU 할당
   * 평균 대기 시간을 매우 효율적으로 줄일 수 있지만, 잦은 선점으로 문맥 전환 오버헤드가 커질 수 있음<br/>

3. **우선순위(Priority) 스케줄링** (선점형 버전)

   * 프로세스가 들어올 때마다 우선순위를 비교해, **더 높은 우선순위**가 도착하면 CPU를 뺏어서 교체
   * 우선순위에 따른 선점이 자주 일어날 수 있음
   * 기아 현상을 방지하기 위해 “대기 시간이 길어질수록 우선순위를 높이는 기법”을 함께 사용<br/>

4. **다단계 큐(Multi-Level Queue) / 다단계 피드백 큐(MLFQ)**

   * 프로세스 특성(대화형 프로세스, 배치 작업 등)에 따라 **여러 개의 큐**로 분류
   * **MLFQ(Multi-Level Feedback Queue)**: 프로세스가 **실행 방식**에 따라 큐를 오르내리며, 시스템 전체 성능을 최적화
   * 일반적으로 **상위 큐**(우선순위 높음)는 **짧은 시간 할당량**, **하위 큐**(우선순위 낮음)는 **긴 시간 할당량**을 주는 식으로 구현<br/>


### 3.4.3 스케줄링 목표와 트레이드오프

1. **목표**

   * **공정성(Fairness)**: 모든 프로세스가 공평하게 CPU를 사용
   * **대기 시간 최소화**
   * **응답 시간(Response time) 최소화**: 대화형(인터랙티브) 시스템에서 사용자 입력에 빠르게 응답
   * **처리량(Throughput) 최대화**: 단위 시간당 처리하는 작업 개수를 늘림<br/>

2. **트레이드오프**

   * 어떤 알고리즘이든, 모든 목표를 동시에 만족하기는 어려움
   * 예: RR은 공정성은 좋지만, 문맥 전환이 잦아 성능 저하 가능
   * 시스템 특성(대화형/일괄처리/실시간 등)에 따라 **적절한 스케줄링 기법**을 선택<br/>


### 3.4.4 요약

* **비선점형** 알고리즘(FCFS, SJF, 비선점 우선순위)은 한 번 CPU를 획득하면 스스로 포기하거나 종료할 때까지 유지
* **선점형** 알고리즘(RR, SRTF, 선점 우선순위, MLFQ)은 CPU를 빼앗는 상황이 발생
* 각 알고리즘마다 **장단점**과 **적용 분야**가 다르므로, 운영체제는 상황에 맞춰 적절히 사용함<br/>

